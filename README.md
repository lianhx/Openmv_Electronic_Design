# Openmv_Electronic_Design
上传几个往年国赛代码。。。这里注明一下来源：mengfanli / openmv_find_bool 
===========================================================
## 重新修订一下处理过程
### 先对图像二值化，然后精准地寻找一次边框
### 在循环中不断地寻找小球，滤除边界框之外的检测结果，并发送相应的数据


主要设计思路.<br>
建立2个3帧的数组buf_x,buf_y.<br>
buf_x[0]是本时刻小球x坐标.<br>
buf_x[1]是上一时刻小球x坐标.<br>
buf_x[2]是上上一时刻小球x坐标.<br>
我们用(buf_x[0]-buf_x[1])/frame_time就得到了当前时刻速度.<br>
frame_time是帧间隔.<br>
同理，(buf_x[1]-buf_x[2])/frame_time是上一时刻速度.<br>
那么（当前时刻速度-上一时刻速度）/frame_time就得到了加速度.<br>

堆的简便设计：.<br>
当我们获得了小球当前时刻坐标，要对其更新的时候.<br>
我们首先使用move_()函数，move_()函数将buf_x[1]赋值给buf_x[2]，.<br>
将buf_x[0]赋值给buf_x[1]，这样，buf_x[0]的位置就空出来了，.<br>
之前的buf_x[2]因为数据过期被之前的buf_x[1]覆盖掉。.<br>

thresholds = [(210, 255)] .<br>
这里意思是我们按照灰度值对每个像素进行二值化处理（非黑即白）.<br>
当灰度值在(0,210)之间认为是黑色.<br>
当灰度值在(210，255)之间认为是白色.<br>

然后用find_blob()的方法检测色块.<br>

uart = UART(3, 115200)用来初始化串口.<br>
串口号在这里不重要.<br>
波特率为115200.<br>

uart.write(str)用来发送数据.<br>

img.draw_circle(),img.draw_string().<br>
这两个函数都是在图像上做标记.<br>
方便观察调试.<br>
